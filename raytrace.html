<!doctype html>
<html>
    <head>
        <title>Ray Trace</title>
    </head>
    <body>
        <canvas width="800" height="350" id="c"></canvas>
        <canvas width="200" height="200" id="d"></canvas>
        <script>
            var probe;
            
            let keys = [];
            document.addEventListener('keydown',(e) => {
                keys.includes(e.code) ? '' : keys.push(e.code);
            });
            
            document.addEventListener('keyup',(e) => {
                while (keys.includes(e.code)) {
                    keys.splice(keys.indexOf(e.code),1);
                };
            });
            
            
            
            let sineTable = (() => {
                let done = [];
                for (let i = 0; i < 360 * 4; i++) {
                    done[i] = Math.sin((i * (Math.PI / 180)) / 4);
                };
                return done;
            })();
            
            // Uses degrees, so that I don't hurty me brain :C
            let sin = (num) => {
                num = num + 360 * 4;
                num = (num * 4) % 360 * 4;
                return sineTable[Math.floor(num)];
            };
            let cos = (num) => {
                num = num + 360 * 4;
                num = (num * 4) % 360 * 4;
                return sineTable[(Math.floor(num) + 90) % 360];
            };
            
            
            
            
            
            
            
            
            
            
            
            
            // Contains all the data about the player, will probably put this in an `Entity` class later on, if this ever gets that far
            let player = {
                pos:{
                    x:2.5,
                    y:2.5
                },
                angle:0,
                speed:.05
            };
            
            
            let map = [
                [2,2,1,2,2,3,3,1,3,3],
                [2,0,0,0,2,3,0,0,0,3],
                [1,0,0,0,0,0,0,0,0,1],
                [2,0,0,0,2,3,0,0,0,3],
                [2,2,1,2,2,3,3,0,3,3],
                [5,5,1,5,5,4,4,0,4,4],
                [5,0,0,0,5,4,0,0,0,4],
                [1,0,0,0,0,0,0,0,0,1],
                [5,0,0,0,5,4,0,0,0,4],
                [5,5,5,5,5,4,4,4,4,4],
            ];
            
            
            
            class Ray {
                constructor(x,y,angle) {
                    this.x = x;
                    this.y = y;
                    this.a = angle;
                    
                    this.dist = 0;
                    this.tileHit = -1;
                }
                step() { // Returns `false` if it hasn't hit something, returns `true` if it has.
                    let done = false;
                    
                    this.x += Math.sin(this.a * (Math.PI / 180)) * renderer.rayStepSize;//sin(this.a) * renderer.rayStepSize;
                    this.y += Math.cos(this.a * (Math.PI / 180)) * renderer.rayStepSize;//cos(this.a) * renderer.rayStepSize;
                    
                    //console.log(this.x + ', ' + this.y);
                    this.tileHit = map[Math.floor(this.x)][Math.floor(this.y)];
                    
                    if (this.tileHit != 0) {
                        done = true;
                        //console.log(Math.floor(this.x) + ', ' + Math.floor(this.y))
                    } else {
                        done = false;
                    };
                    this.dist += 1;//renderer.rayStepSize;
                    return done;
                }
            }
            
            
            
            class Color {
                constructor(h,s,l) {
                    this.h = h;
                    this.s = s;
                    this.l = l;
                }
                
                toString() {
                    return `hsl(${this.h}deg,${this.s}%,${this.l}%)`;
                }
                
                makeCopy() {
                    return new Color(this.h,this.s,this.l);
                }
            }
            
            
            
            
            // Handles everything to do with rendering
            let renderer = {
                rayStepSize:.025,
                fov:90, // Degrees
                colors:[
                    new Color(0,100,100),
                    new Color(0,0,0),
                    new Color(0,100,50),
                    new Color(120,100,50),
                    new Color(240,100,50),
                    new Color(60,100,50)
                ], // Each color goes to each number in the map
                floorColor:'#550',
                ceilColor:'#777'
            };
            
            // Set up canvas
            let c = document.getElementById('c');
            let ctx = c.getContext('2d');
            
            
            
            
            
            // Rendering
            setInterval(() => {
                
                // Start by drawing the ceiling and floor
                ctx.fillStyle = renderer.floorColor;
                ctx.fillRect(0, 0, c.width, c.height);
                ctx.fillStyle = renderer.ceilColor;
                ctx.fillRect(0, 0, c.width, c.height / 2);
                    
                
                let iteration = 0;
                for (let i = player.angle - renderer.fov / 2; i < player.angle + renderer.fov / 2; i++) { // For every ray, according to the FOV. `i` is the angle
                    let ray = new Ray(player.pos.x,player.pos.y,i);
                    
                    // Step ray until it hits something
                    while (!ray.step()) {};
                    
                    // Now draw a line to the screen
                    let rayDistUnits = ray.dist * renderer.rayStepSize;
                    let finalDist = rayDistUnits * .025; // Some constant, controls height of lines
                    
                    let color = renderer.colors[ray.tileHit].makeCopy();
                    // Darken color depending on distance traveled
                    color.l -= rayDistUnits * 6;
                    ctx.fillStyle = color;
                    ctx.fillRect(iteration * (c.width / renderer.fov), (c.height / 2) - (.5 / finalDist * 3),
                                 c.width / renderer.fov + 1,           1 / finalDist * 3);
                    
                    
                    iteration++;
                };
                
                
                
                // Movement logic
                
                if (keys.includes('ArrowRight')) {
                    player.angle+=5;
                };
                
                if (keys.includes('ArrowLeft')) {
                    player.angle-=5;
                };
                
                
                let nextPos =  {x:player.pos.x,y:player.pos.y};
                
                if (keys.includes('KeyW')) {
                    nextPos.x += Math.sin(player.angle * (Math.PI / 180)) * player.speed;
                    nextPos.y += Math.cos(player.angle * (Math.PI / 180)) * player.speed;
                };
                if (keys.includes('KeyS')) {
                    nextPos.x -= Math.sin(player.angle * (Math.PI / 180)) * player.speed;
                    nextPos.y -= Math.cos(player.angle * (Math.PI / 180)) * player.speed;
                };
                if (keys.includes('KeyA')) {
                    nextPos.x -= Math.cos(player.angle * (Math.PI / 180)) * player.speed;
                    nextPos.y += Math.sin(player.angle * (Math.PI / 180)) * player.speed;
                };
                if (keys.includes('KeyD')) {
                    nextPos.x += Math.cos(player.angle * (Math.PI / 180)) * player.speed;
                    nextPos.y -= Math.sin(player.angle * (Math.PI / 180)) * player.speed;
                };
                
                // Collision
                
                if (!map[Math.floor(nextPos.x)][Math.floor(player.pos.y)]) {
                    player.pos.x = nextPos.x;
                };
                
                if (!map[Math.floor(player.pos.x)][Math.floor(nextPos.y)]) {
                    player.pos.y = nextPos.y;
                };
                
            },40);
            
            // Debug shit
            let d = document.getElementById('d');
            let dtx = d.getContext('2d');
            let dScale = 10;
            
            setInterval(() => {
                
                
                dtx.fillStyle = '#fff';
                dtx.fillRect(0,0,d.width,d.height);
                
                for (let y = 0; y < map.length; y++) {
                    for (let x = 0; x < map[y].length; x++) {
                        dtx.fillStyle = renderer.colors[map[y][x]];
                        dtx.fillRect(dScale*x,dScale*y,dScale,dScale);
                    };
                };
                
                dtx.fillStyle = '#000';
                dtx.fillRect(player.pos.y * dScale - dScale/4,player.pos.x * dScale - dScale/4,dScale/2,dScale/2);
                dtx.beginPath();
                dtx.moveTo(player.pos.y*dScale,player.pos.x*dScale);
                dtx.lineTo(player.pos.y*dScale+Math.cos(player.angle * Math.PI / 180)*dScale*2,player.pos.x*dScale+Math.sin(player.angle * Math.PI / 180)*dScale*2);
                dtx.stroke();
            },10);
            
            
            
        </script>
    </body>
</html>